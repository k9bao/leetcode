# 说明

给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

示例 1：

输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21
示例 4：

输入：x = 0
输出：0

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-integer
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 思路

### 方案一

1. 如何是负数，先记录符号，然后转为正数处理
2. 将各位上的数字拆分成单独数字加入列表
3. 对列表值乘以对应为的进位，求出反序结果
4. 判断是否大于2^32,如果大于2^32,则将结果存为0
5. 乘上前边的符号位

### 官网方案

1. 类似进栈出栈逻辑，假设原始是x,反转后数字是rev
2. 通过x%10取个位数字pop，x/=10
3. 预判一下第四步是否会越界，如果越界直接返回0，否则执行第四步
4. rev = rev*10+pop

```C++
int reverseGW(int x) {
    int rev = 0;
    while (x != 0) {
        int pop = x % 10;
        x /= 10;
        if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && pop > 7)) //0x7F FF FF FF
            return 0;
        if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && pop < -8)) //0x8F FF FF FF
            return 0;
        rev = rev * 10 + pop;
    }
    return rev;
}
```
