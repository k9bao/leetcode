4. 寻找两个正序数组的中位数
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。

进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？

 

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
示例 3：

输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
示例 4：

输入：nums1 = [], nums2 = [1]
输出：1.00000
示例 5：

输入：nums1 = [2], nums2 = []
输出：2.00000
 

提示：

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106

## 方案一

1. 计算出需要查找的索引值find
2. 遍历二个数组，找到对应的索引值
3. 如果中位数需要二个值计算，需要找到下一个索引值find+1

注意点：

1. 需要关注遍历结束条件，可能某一个就提前遍历结束
2. 计算find+1索引是，需要关注是否是最后一个元素问题

时间复杂度o(m+n),空间复杂度o(1)

## 方案二

0. 假设i是nums1中位数索引，j是nums2中位数索引，退出条件是i+j==(len(nums1)+len(nums2)-1)/2或某一个数组查找结束
1. 初始化left1=0，right1=nums2.size()-1,left2=0，right2=nums2.size()-1,
2. 先找出nums1[left1:right1]的中位数索引i，再找出nums2[left2:right2]的中位数索引j,判断是否满足退出条件，如果不满足执行步骤3
3. 如果`nums[i]<mum[j]`,left1=i,right2=j,重复步骤2
4. 如果`nums[i]>=mum[j]`,right1=i,left2=j,重复步骤2

时间复杂度o(log(m+n)),空间复杂度o(1)
